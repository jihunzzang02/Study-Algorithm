## round 함수
반올림할때 씀, 소수 몇째자리 수까지 표현~
print( round(123.456,2))
>>123.45
#################################################################################

x.isalpha() 알파벳인지 아닌지 True False 반환
/  나누기 결과값 실수형 반환
// 나누고 몫을 반환
%  나누고 나머지 반환
** 거듭제곱 연산
#################################################################################

#순열 조합
from itertools import permutations
from itertools import combinations
item = ['a','b','c']
list(combinations(item,2))
>>>[('a', 'b'), ('a', 'c'), ('b', 'c')]
list(map(''.join, permutations(item,2)))
>>> ['ab', 'ac', 'ba', 'bc', 'ca', 'cb']
list(map(''.join, combinations(item,2)))
>>> ['ab', 'ac', 'bc']
#################################################################################

## Counter사용방법 
## 컨테이너에 동일한 값의 자료가 몇개인지를 파악하는데 사용하는 객체
from collections import Counter
lst = ['aa', 'cc', 'dd', 'aa', 'bb', 'ee']
print(Counter(lst))
>>>Counter({'aa': 2, 'cc': 1, 'dd': 1, 'bb': 1, 'ee': 1})

Counter(lst).most_common()
>>> [('aa', 2), ('cc', 1), ('dd', 1), ('bb', 1), ('ee', 1)]
하면 정렬된 채로 나옴

Counter(lst).most_common(n=2)
>>>[('aa', 2), ('cc', 1)]
하면 정렬된 채로 2개만 나옴

차집합구할때 
##  Counter(participant) - Counter(completion) 위와 같이 빼기도 가능

from collections import Counter
lst1 = ['a','b','c','a','c','f','g']
tup1 = ('b','d','e','e','f','f','g','h','h')
ct1 = Counter(lst1)
ct2 = Counter(tup1)
print(ct1)
>>> Counter({'a': 2, 'b': 1, 'c': 2, 'f': 1, 'g': 1})
print(ct2)
>>> Counter({'b': 1, 'd': 1, 'e': 2, 'f': 2, 'g': 1, 'h': 2})
list(ct1.elements())
>>> ['a', 'a', 'b', 'c', 'c', 'f', 'g']
list(ct2.elements())
>>> ['b', 'd', 'e', 'e', 'f', 'f', 'g', 'h', 'h']
ct1+ct2
>>> Counter({'a': 2, 'b': 2, 'c': 2, 'f': 3, 'g': 2, 'd': 1, 'e': 2, 'h': 2})
차집합 ct1-ct2
>>> Counter({'a': 2, 'c': 2})
교집합 ct1&ct2 
>>> Counter({'b': 1, 'f': 1, 'g': 1})
합집합 ct1|ct2
>>>Counter({'a': 2, 'b': 1, 'c': 2, 'f': 2, 'g': 1, 'd': 1, 'e': 2, 'h': 2})
list((ct1|ct2).elements())
>>> ['a', 'a', 'b', 'c', 'c', 'f', 'f', 'g', 'd', 'e', 'e', 'h', 'h']
#################################################################################


#리스트 컴프리헨션
x = [i for i in range(10)]
>>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
x = [i for i in range(10) if i%2 ==1]
>>> [1, 3, 5, 7, 9]
x = [i*i for i in range(1,10)]
>>> [1, 4, 9, 16, 25, 36, 49, 64, 81]
n*m행렬 만들기 x = [[0]*m for _ in range(n)]
x = [[0]*4 for _ in range(3)]
>>>[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]
#################################################################################


## defaultdict 사용법
from collections import defaultdict
temp = defaultdict(int)
하면 디폴트값이 int인 딕셔너리 생성
temp['x'] 선언할 시
자동으로 0이 지정됨
{'x' : 0} 

temp = defaultdict(list)
temp = defaultdict(set)
모두 사용가능

# 예시
letters = 'dongdongfather'
letters_dict = defaultdict(int)
for k in letters:
    letters_dict[k]+=1

letters_dict = {'d':2, 'o':2, 'n':2 ....... 이런식으로 나옴
#################################################################################




## hash() 함수방법
hash('123')
>>> 1710988942867749935
#################################################################################


## zip사용방법
>>> numbers = (1, 2, 3)
>>> letters = ("A", "B", "C")
>>> pairs = list(zip(numbers, letters))
>>> pairs
[(1, 'A'), (2, 'B'), (3, 'C')]

>>> keys = [1, 2, 3]
>>> values = ["A", "B", "C"]
>>> dict(zip(keys, values))
{1: 'A', 2: 'B', 3: 'C'}

>>> dict(zip(["year", "month", "date"], [2001, 1, 31]))
{'year': 2001, 'month': 1, 'date': 31}

>>> numbers = ["1", "2", "3"]
>>> letters = ["A"]
>>> list(zip(numbers, letters))
[('1', 'A')]
#################################################################################


## bisect  정렬된 순서를 유지하면서 리스트에 x를 삽입할 인덱스 반환
bisect_lect(배열명,원소) >>> 삽입할 가장 왼쪽 인덱스 반환
bisect_right(배열명,원소) >>> 삽입할 가장 오른쪽 인덱스 반환

from bisect import bisect_left, bisect_right
a= [1,2,4,4,8]
x=4
print(bisect_left(a,x))    >>>  2
print(bisect_right(a,x))   >>>  4
#################################################################################



## 아스키코드 변환
문자를 아스키코드로
ord('A')  >>>  65
ord('Z')  >>>  91

아스키코드를 문자로
chr(65)   >>> 'A'
#################################################################################


## 숫자만 찾기
import re
s = "{{2},{2,1},{2,1,3},{2,1,3,4}dfsgdsfgfwaef1244}"
re.findall('\d+',s)
>>> ['2', '2', '1', '2', '1', '3', '2', '1', '3', '4', '1244']
특정 문자만 찾기( +,*,-만 찾기)
re.sub('[^+-*],'','구0ㄹ1380ㄱ+*$*@_!-')
>>>+**-
#################################################################################
import heapq

## 힙 생성
temp_heap = []

## 힙 원소추가
heapq.heappush(temp_heap, 4)

## 힙 원소삭제
## heappop이용 시, 가장 작은 원소를 삭제 후 그 값을 리턴
heapq.heappop(temp_heap)

## 최소(최대)값을 삭제하지 않고 얻기
temp_heap[0]

## 기존 리스트를 힙으로 변환
temp_heap = [4, 1, 7, 3, 8, 5]
heapq.heapify(temp_heap)

## heapq는 최소 힙(최소값이 부모노드)기능만 작동하기에 최대 힙(최대값이 부모노드)로 하기위해선
## heappush할 때 튜플의 형태 (우선 순위, 값)으로 삽입/삭제 가능.
import heapq
nums = [4, 1, 7, 3, 8, 5]
heap = []
for num in nums:
  heapq.heappush(heap, (-num, num))
  
## 힙을 이용한 힙정렬
import heapq
def heap_sort(nums):
    heap = []
    for num in nums:
        heapq.heappush(heap, num)
    sorted_nums = []
    while heap:
        sorted_nums.append(heapq.heappop(heap))
    return sorted_nums
print(heap_sort([4, 1, 7, 3, 8, 5]))
>>> [(-8, 8), (-7, 7), (-5, 5), (-1, 1), (-3, 3), (-4, 4)]


